{"noir_version":"1.0.0-beta.11+fd3925aaaeb76c76319f44590d135498ef41ea6c","hash":"9543637416141111981","abi":{"parameters":[{"name":"hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"indices","type":{"kind":"array","length":3,"type":{"kind":"integer","sign":"unsigned","width":32}},"visibility":"public"},{"name":"values","type":{"kind":"array","length":3,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"segment","type":{"kind":"array","length":2048,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"}],"return_type":null,"error_types":{"11454949385291529723":{"error_kind":"string","string":"The hashes don't match"},"12112278161989238248":{"error_kind":"string","string":"Values don't match"}}},"bytecode":"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","debug_symbols":"pZTbisMgFEX/xec8eDQX7a8MQ7GpLYKYYJPCUPrvY4I7bQcSyvQpy6N7xRve2NEexvPehVN3YbuvGztE5707733XmsF1IVVv94KhuR+itanEnvpTqjfRhoHtwuh9wa7Gj/OgS2/C/B1MTL28YDYc0zcJT87bie7FI83XoySbHKZKLPHqNU9b+ZogkE29GEi/PYO6gkDJtRnI9bzgpLNAcPGYQfW+QPJFINWKYGMFol4m0Oi1FWzmsYVC8f/kVYm8lp/9/0/+O7VM6+LLrWWCqzKNLSao5q1NUAMagALoDJoDCCAAElACYNYwa5g1zDqbiXMAAQRAAkpABagBDUABYCaYCWaCmWAmmAlmgpmSuZkhmfUMOlcEzxVBqCTzdH+uJjpz8DY/EacxtE8vxvDTowdvSh+71h7HaKdzmvvSyf0C","file_map":{"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"50":{"source":"use std::hash::blake3;\n\nfn main(hash: pub [u8;32], indices: pub [u32;3], values: pub [u8;3], segment: [u8; 2048]) {\n    let given_hash = blake3(segment);\n    assert(hash == given_hash, \"The hashes don't match\");\n    for i in 0 .. indices.len() {\n        assert(segment[indices[i]] == values[i], \"Values don't match\");\n    }\n}\n","path":"/home/user/code/projects/fairfy/circuits/commitReveal/src/main.nr"}},"names":["main"],"brillig_names":[]}