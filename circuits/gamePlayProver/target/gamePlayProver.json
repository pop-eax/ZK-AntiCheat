{"noir_version":"1.0.0-beta.7+24c053fba747770cf8d3f813d22cfa003714dfb6","hash":"12641656160013716199","abi":{"parameters":[{"name":"verification_key","type":{"kind":"array","length":128,"type":{"kind":"field"}},"visibility":"private"},{"name":"proof","type":{"kind":"array","length":456,"type":{"kind":"field"}},"visibility":"private"},{"name":"public_inputs","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"public"},{"name":"accumlator","type":{"kind":"field"},"visibility":"public"},{"name":"new_root","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"nZTNjoQgDMffhbMHyqfMq2w2E1SckBA0jE6yMfPui664esBMvFih/sq/pXVCjanGx936tnui29eEqmCds4+762o92M7H3eldoLS8D8GYuIV2/kj1Ohg/oJsfnSvQS7tx+ejZa7/YQYfoxQUyvok2BmytM/Pbu/incR5lWK0wZ3zD+ZGHPA+C8jUASCi3CIR8qkDSJF8ykVNwxhOWeEFzPMvzlJOVZ7A7Xx54nucJKVMJCcUkF0Gc1BBEkgBQ8isaJIikIdYzF6E80SAl3e5RZbNQ+QiKpUZQvLzAAyZbFbDgV3JQWzODItkcPusleZyG77jStQ2H+UU41rtAsDzJfHsFon+GRTN340sHqytn1nFvR1/vpn/46ZMn/R/60NWmGYOZT1p88exf","file_map":{"22":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time.\n// The message can be a string, a format string, or any value, as long as it is known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<T>(predicate: bool, message: T) {}\n\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_add(y)\")]\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_sub(y)\")]\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_mul(y)\")]\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::ops::arith::WrappingMul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, zero.wrapping_mul(one));\n\n        // 0*1==0\n        assert_eq(zero, one.wrapping_mul(zero));\n\n        // 1*1==1\n        assert_eq(one, one.wrapping_mul(one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, zero.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, two_pow_64.wrapping_mul(zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, two_pow_64.wrapping_mul(one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, one.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, two_pow_64.wrapping_mul(two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, u128_max.wrapping_mul(u128_max));\n    }\n}\n","path":"std/lib.nr"},"50":{"source":"use poseidon::poseidon2::Poseidon2::hash;\n\nglobal HONK_VK_SIZE: u32 = 128;\nglobal HONK_PROOF_SIZE: u32 = 456;\nglobal HONK_IDENTIFIER: u32 = 1;\n\nfn main(\n    verification_key: [Field; HONK_VK_SIZE],\n    proof: [Field; HONK_PROOF_SIZE],\n    public_inputs: pub [Field; 2],\n    accumlator: pub Field,\n    new_root: pub Field\n    // proof2: [Field; HONK_PROOF_SIZE],\n    // public_inputs2: pub [Field; 2],\n) {\n    std::verify_proof_with_type(\n        verification_key,\n        proof,\n        public_inputs,\n        0x0,\n        HONK_IDENTIFIER,\n    );\n\n    // std::verify_proof_with_type(\n    //     verification_key,\n    //     proof2,\n    //     public_inputs2,\n    //     0x0,\n    //     HONK_IDENTIFIER,\n    // );\n    assert(hash([public_inputs[0], accumlator], 2) == new_root);\n}","path":"/home/user/code/projects/anticheatz/circuits/gamePlayProver/src/main.nr"},"57":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/home/user/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"}},"names":["main"],"brillig_names":[]}