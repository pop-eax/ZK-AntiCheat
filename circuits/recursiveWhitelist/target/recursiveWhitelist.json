{"noir_version":"1.0.0-beta.7+24c053fba747770cf8d3f813d22cfa003714dfb6","hash":"10581489607110004044","abi":{"parameters":[{"name":"verification_key","type":{"kind":"array","length":128,"type":{"kind":"field"}},"visibility":"private"},{"name":"proof","type":{"kind":"array","length":456,"type":{"kind":"field"}},"visibility":"private"},{"name":"public_inputs","type":{"kind":"array","length":33,"type":{"kind":"field"}},"visibility":"public"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"dZDRCoQgEEX/ZZ59yKRt6VeWJcymEETFdGEJ/32nqLYeenGcuZ4rc2fosUtjq+3gJmheM3RBG6PH1jglo3aWpnNmsLdtDIg0gpNOlJcBbYTGJmMYfKRJ66PJS7vWKAOpBQO0PVUyHLTB5ZbZny7u0VLUGyxqceDVlef3PH+IajPgNX8eDmWZ85s6qXS47AwFiQw4nXmxDVp2Brc0hmTVKZz49buyx+eDU9ingIvpqtE3Pw==","file_map":{"22":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time.\n// The message can be a string, a format string, or any value, as long as it is known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<T>(predicate: bool, message: T) {}\n\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_add(y)\")]\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_sub(y)\")]\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_mul(y)\")]\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::ops::arith::WrappingMul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, zero.wrapping_mul(one));\n\n        // 0*1==0\n        assert_eq(zero, one.wrapping_mul(zero));\n\n        // 1*1==1\n        assert_eq(one, one.wrapping_mul(one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, zero.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, two_pow_64.wrapping_mul(zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, two_pow_64.wrapping_mul(one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, one.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, two_pow_64.wrapping_mul(two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, u128_max.wrapping_mul(u128_max));\n    }\n}\n","path":"std/lib.nr"},"50":{"source":"\nglobal HONK_VK_SIZE: u32 = 128;\nglobal HONK_PROOF_SIZE: u32 = 456;\nglobal HONK_IDENTIFIER: u32 = 1;\n\nfn main(\n    verification_key: [Field; HONK_VK_SIZE],\n    proof: [Field; HONK_PROOF_SIZE],\n    public_inputs: pub [Field; 33],\n) {\n    std::verify_proof_with_type(\n        verification_key,\n        proof,\n        public_inputs,\n        0x0,\n        HONK_IDENTIFIER,\n    );\n}","path":"/home/user/code/projects/anticheatz/circuits/recursiveWhitelist/src/main.nr"}},"names":["main"],"brillig_names":[]}