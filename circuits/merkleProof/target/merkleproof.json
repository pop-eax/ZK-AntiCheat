{"noir_version":"1.0.0-beta.7+24c053fba747770cf8d3f813d22cfa003714dfb6","hash":"9305220175375797383","abi":{"parameters":[{"name":"root","type":{"kind":"field"},"visibility":"public"},{"name":"paths","type":{"kind":"array","length":32,"type":{"kind":"field"}},"visibility":"private"},{"name":"bad_hashes","type":{"kind":"array","length":1,"type":{"kind":"field"}},"visibility":"public"}],"return_type":null,"error_types":{"7021465804464093846":{"error_kind":"string","string":"roots don't match"},"14370616181497445055":{"error_kind":"string","string":"evil hash detected"}}},"bytecode":"H4sIAAAAAAAA/9Wca3MUVRCGT24kIYQQkhBCyP1+n9lLdjf3AAoqKioqKiqJSURFBEVFREVFRUVFRURFxQiKioKKiojy0f/jD7B8j5mhujbQdYqcQ1VP1VMzbJMn0503u72Vqs1QM8cFMB5cZwfnDDX7yAzOI8HZm9vhZxBX1OuNxSYTkUk/6o95kdR4Mu7F4uO9ST/px5PxiUgyGp1MxpKJ1Hgq4aX8WHTSn4qnolOBrM7efXm093qXzddbHkA9uXFb3qsZiEwBgWhw2XyD5QE0KNmByBIQiEaXzTdaHkCjkh2IbAGBaHLZfJPlATQp2YHIERCIZpfNN1seQLOSHYh5AgLR4rL5FssDaFGyA5ErIBCtLptvtTyAViU7EHkCAtHmsvk2ywNoU7IDkS8gEO0um2+3PIB2JTsQ8wUEosNl8x2WB9ChZAeiQEAgOl0232l5AJ1KdiAWCAhEl8vmuywPoEvJDkShgEB0u2y+2/IAupXsQCwUEIgel833WB5Aj5IdiCIBgfBcNu9ZHoCnZAdikYBA+C6b9y0PwFeyA1EsIBARl81HLA8gomQHYrGAQERdNh+1PICokh2IEgGBiLlsPmZ5ADElOxClAgIRd9l83PIA4kp2IMoEBKLXZfO9lgfQq2QHYomAQCRcNp+wPICEkh2IcgGBSLpsPml5AEklOxBLBQQi5bL5lOUBpJTsQFQICESfy+b7LA+gT8kOxDIBgeh32Xy/5QH0K9mBqBQQiAGXzQ9YHsCAkh2I5QICMeiy+UHLAxhUsgNRJSAQQy6bH7I8gCElOxDVAgIx7LL5YcsDGFayA1EjIBAjrpt3MQCpgagVEIhRl82PWh7AqLIfCKK8GApb7hUWf2gu73Plld9nJP0BfW/6L930F03zb3DOJNcryPXK4Dr8ulXgGnAtWB08fil3FnFkG7rXgOvA9eAGxp1DHPMM3WvBjeAmcDPjziWOPEP3OnALuBXcxrjziWO+oXs9uB3cAe5k3AXEscDQvQHcBe4G9zDuQuJYaOjeCO4F94H7GXcRcSwydG8CY2rms2QeYNzFxLHY0D0BJsEUeJBxlxBHqaF7M3gIPAweYdxlxLHE0L0FPAq2gscYdzlxLDV0bwPbwePgCcZdQRzLDN07wJPgKfA0464kjuWG7p3gGbALPMu4q4ij2tC9GzwHngcvMO4a4qg1dO8BL4KXwMuMexVxrDF07wWvgFfBa4x7LXGsM3TvA6+DN8CbjHs9cWwwdO8Hb4G3wTuMeyNxbDJ0HwDvgvfA+4x7gjg2G7oPgg/AIfAh495CHNsM3YfBR+Bj8Anj3kEcOw3dR8Cn4DPwOePeTRx7DN1HwRdgGnzJuPcSxz5D9zFwHHwFvmbc+4njgKH7BPgGfAu+Y9wHieOwofsk+B78AE4x7iPEcdTQfRr8CH4CPzPuY8RxwtB9BvwCfgW/Me6TxHHa0H0W/A7OgT8Y9xniOGvoPg/+BH+pmc+lCx8PD9vvu6hrru8Lziu7bzrD3mvJTHX/WUFN79t6z9a7sd6J9R6r91e9c+pdU++Hei/Uu5ze4YqDn5HekfRupPcZvcfo3UPvHHpP0PuBfk3Xr+X69bdazbxW1pLZ66PuMtcZwfnCuenB1ae2/k1K/9/35Wo5TC2XqeUztQKmVsjUiphaMVMrYWplTK2cqVUwtUqmVsXUaphaHVNrYGpNTK2FqbUxtQ6m1sXUepiaz9SiTC3O1BJMLcXU+pnaIFMbZmpjwfnQrunj/4xuD/958fcyP+1cRur00/a8uR1+6C914/dy1eyjjFyXpvVJn7tGLN1D6Auf13LU7CMzrRb+37y0+8uwf39++r1kXeJ7hUf43FVKHgvn+R8/mdO7KFYAAA==","debug_symbols":"ndXRrqIwEAbgd+HaC2baaafnVTYbg4onJAQNR06yMefdF/pPXb3AbLjpKPX/aGsL9+rUHqbPfTecL1/Vx697dRi7vu8+9/3l2Ny6yzBfvf/sqvJ1fxvbdr5UPfXPqWsztsOt+himvt9V300/5R99XZsh11szzr31rmqH01xn8Nz17fLpZ/cvXa9HyZGFyYVHXP4/L6Hkw6a8asknvyEvyVs+OLeW9+t5J2x5T0/jjy95Wc8zazKAXc1rQnizAhTKEIhUtowhUvkTOLp6TdA3Y4jRlTHEtDqLtC4kLwYk0Q15qvmxCnWQLXNIdXpsJV6dw5u9FKUcpBh4w14M9NiLrFvydbl/oC3311Dur/p6ln7P35pjN748fap63v67inLLuXW59bmV3IbcxtxqbhNSFkaaECfkCQBBIBAEg4AQFIbCNgYoDIWhMBSGwlAYCkNxUBwUZ1OB4qA4KA6Kg+KgOCgeiofioXhbESgeiofioXgoHopAESgCRaCILSwUgSJQBIpACVAClAAlQAl+eVDMVawGq9GqWk2osbZKVtmqs2peNC+aF82L5kXz1Dw1T81T89Q8NU/NU/PUPDUvmZfMS+Yl85J5ybxkXlq85ZH93Yxdc+hbe6Oep+H49IK9/bmWnvIKvo6XY3uaxnY5DrlvPiB/AQ==","file_map":{"50":{"source":"use poseidon::poseidon2::Poseidon2::hash;\n\nfn main(root: pub Field, paths: [Field; 32], bad_hashes: pub [Field; 1]) {\n    for p in paths {\n        for k in bad_hashes {\n            assert(p != k, \"evil hash detected\");\n        }\n    }\n\n    let mut curr_path = paths;\n\n    let depth = 6;\n    let bounds= [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096];\n    \n    for j in 1 .. depth+1  {\n        let idx = depth - j;\n        let bound = bounds[idx];\n        let mut skip = false;\n        let mut k = 0;\n        for i in 0 .. bound-1 {\n            if !skip {\n                let interm =hash([curr_path[i], curr_path[i+1]], 2);\n                // let interm : [u8; 32] = std::hash::blake3(curr_path[i].concat(curr_path[i+1]));\n                curr_path[k] = interm;\n                k += 1;\n            }\n            skip = !skip;\n        }\n    }\n    assert(root == curr_path[0], \"roots don't match\");\n}\n","path":"/home/user/code/projects/anticheatz/circuits/merkleProof/src/main.nr"},"57":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/home/user/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"}},"names":["main"],"brillig_names":["directive_invert"]}